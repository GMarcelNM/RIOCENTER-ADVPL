#include "protheus.ch"
#include "tbiconn.ch"

//ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
//±±ºPrograma  ³ModeloAba ºAutor  ³George Allan        º Data ³  01/09/10   º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºDesc.     ³Funcao da lib que serve para montar uma tela, mestre detalheº±±
//±±º          ³                                                            º±±
//±±º          ³                                                            º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºUso       ³                                                            º±±
//±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
User Function ModeloAba(nOpc, cFunVars, aFieldsCopia, lAuto, aDados)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Este aPrivates eh utilizado para inicializar as variaveis private antes ³
	//³da primeira chamada do modelo aba                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	Local	aPrivates	:= {{"aTela"	 		," Array(0, 0)"	 			},;
								 {"aGets"     		,"	Array(0)"					},;
								 {"aFilhas"	 		,"	{}"							},;
								 {"aOrdem"	 		," {}"							},;
								 {"_aSeek"	 		," {}"							},;
								 {"aPK"		 		," {}"							},;
								 {"aWhile"	 		," {}"							},;
								 {"aNomes"	 		," {}"							},;
								 {"_aChaveOrd"		,"	{}"							},;
								 {"_aChave"			,"	{}"							},;
								 {"aIniPos"			,"	{}"							},;
								 {"cCabec"			," ''"							},;
								 {"aOrdItem"		," {}"							},;
								 {"_aChave"			,"	{}"							},;
								 {"aPe"	  			," {}"							},;
								 {"cTitulo"			," ''"							},;								 
								 {"cRepCabec"		," ''"							},;								 
								 {"aRepFilhas"		," {}"							},;
								 {"aTFolder"  		," {}"							},;								 
								 {"aFiltro"	  		," {}"							},;								 
 								 {"nAux"		  		," 1"								},;
 								 {"cArquivo"  		,"nil"							},; 								 
 								 {"nAbaAtu"	  		," 1"								},;
 								 {"aButtons"  		," {}"							},;
 								 {"aReadOnly"		," {}"							},; 								 
 								 {"lAutoDel"		," .F."							},;
 								 {'nRecNoCabec'	,"''"								}}

	local cPrivates	:= ''
	local i
	local nI, nX, nT
	local nFreeze, aAlter, aAddAction
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Inicializei as variaveis assim porque nao consegui inicializa-las³
	//³com funcoes automaticas, depois olho melhor                      ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Ou seja,  o modelo aba so serve para ate 20 abas³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	local aHeader01		:= {} ;local aHeader02	:= {} ;local aHeader03	:= {} ;local aHeader04	:= {} ;local aHeader05	:= {} ;local aHeader06	:= {} ;local aHeader07	:= {} ;local aHeader08	:= {} ;local aHeader09	:= {} ;local aHeader10 	:= {}
	local aHeader11		:= {} ;local aHeader12	:= {} ;local aHeader13	:= {} ;local aHeader14	:= {} ;local aHeader15	:= {} ;local aHeader16	:= {} ;local aHeader17	:= {} ;local aHeader18	:= {} ;local aHeader19	:= {} ;local aHeader20 	:= {}
	local aCols01			:= {} ;local aCols02		:= {} ;local aCols03		:= {} ;local aCols04		:= {} ;local aCols05		:= {} ;local aCols06		:= {} ;local aCols07		:= {} ;local aCols08		:= {} ;local aCols09		:= {} ;local aCols10 	:= {}
	local aCols11			:= {} ;local aCols12		:= {} ;local aCols13		:= {} ;local aCols14		:= {} ;local aCols15		:= {} ;local aCols16		:= {} ;local aCols17		:= {} ;local aCols18		:= {} ;local aCols19		:= {} ;local aCols20 	:= {}
	local oGet02		:= {} ;local oGet03		:= {} ;local oGet04		:= {} ;local oGet05		:= {} ;local oGet06		:= {} ;local oGet07		:= {} ;local oGet08		:= {} ;local oGet09		:= {} ;local oGet10 		:= {}
	local oGet11			:= {} ;local oGet12		:= {} ;local oGet13		:= {} ;local oGet14		:= {} ;local oGet15		:= {} ;local oGet16		:= {} ;local oGet17		:= {} ;local oGet18		:= {} ;local oGet19		:= {} ;local oGet20 		:= {}
	local aNoFields		:= nil
	local aYesFields		:= nil
	local lOnlyYes			:= nil
	local lUserFields		:= nil
	local aYesUsado		:= nil 
	local aAcho				:= nil
	local aField			:= nil
	local aFolder			:= nil
    Local nMaxLinhas 		:= 9999
    local cFiltroQuery	:= ''
    local z
   
    Private oSXS         := CLASSXS():New()       // Definição da Classe - Tabelas SX
    Private aCpoEnchoice := {}
	Private nId          := 0

    Private oGet01			:= {} 
	Private aColsAux01	:= {} ;Private aColsAux02	:= {} ;Private aColsAux03	:= {} ;Private aColsAux04	:= {} ;Private aColsAux05	:= {} ;Private aColsAux06	:= {} ;Private aColsAux07	:= {} ;Private aColsAux08	:= {} ;Private aColsAux09	:= {} ;Private aColsAux10	:= {}	
	Private aColsAux11	:= {} ;Private aColsAux12	:= {} ;Private aColsAux13	:= {} ;Private aColsAux14	:= {} ;Private aColsAux15	:= {} ;Private aColsAux16	:= {} ;Private aColsAux17	:= {} ;Private aColsAux18	:= {} ;Private aColsAux19	:= {} ;Private aColsAux20	:= {}	
	Private aLimpo01		:= {} ;Private aLimpo02	:= {} ;Private aLimpo03	:= {} ;Private aLimpo04	:= {} ;Private aLimpo05	:= {} ;Private aLimpo06	:= {} ;Private aLimpo07	:= {} ;Private aLimpo08	:= {} ;Private aLimpo09	:= {} ;Private aLimpo10	:= {}
	Private aLimpo11		:= {} ;Private aLimpo12	:= {} ;Private aLimpo13	:= {} ;Private aLimpo14	:= {} ;Private aLimpo15	:= {} ;Private aLimpo16	:= {} ;Private aLimpo17	:= {} ;Private aLimpo18	:= {} ;Private aLimpo19	:= {} ;Private aLimpo20	:= {}
	Private lReplica		:= .F.
	aColsAux01				:= {} ;aColsAux02	:= {} ;aColsAux03	:= {} ;aColsAux04	:= {} ;aColsAux05	:= {} ;aColsAux06	:= {} ;aColsAux07	:= {} ;aColsAux08	:= {} ;aColsAux09	:= {} ;aColsAux10	:= {}	
	aColsAux11				:= {} ;aColsAux12	:= {} ;aColsAux13	:= {} ;aColsAux14	:= {} ;aColsAux15	:= {} ;aColsAux16	:= {} ;aColsAux17	:= {} ;aColsAux18	:= {} ;aColsAux19	:= {} ;aColsAux20	:= {}	
	SetPrvt('_cTabela,nPosFil,nPosFiltro,aAux,cDom,nPosDom,cGetDom,cHeaderDom,cColsDom,cCdom,nPosCdom,cGetCdom,cHeaderCdom,cColsCdom,cColsAux,n')
	Private cArquivo,nHdlPrv

   default lAuto	:= .F. 
	default aDados := {}
   
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Joga variaveis privates numa string, esta string sera utilizada no SetPrvt³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	if nOpc  == 0
		for i:= 1 to len(aPrivates)
			cPrivates	+= aPrivates[i][1] + ','
		next
		alert("Fonte 2021-03-29 09:31 - modeloaba")          
		return cPrivates
	endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se o modeloaba for chamado com o nOpc = 1, significa que eh para       ³
	//³iniciar as variaveis, entao retorna o array com as variaveis que devem ³
	//³ser private fora do modeloaba (na funcao chamadora)                    ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	if nOpc	== 1      
		return aPrivates
	endif 

	Default nOpc			:= 2								
	default aFieldsCopia	:= {}
	Private VISUAL			:= nOpc == 2	
	Private INCLUI			:= nOpc == 3
	Private ALTERA			:= nOpc == 4
	Private DELETA			:= nOpc == 5
	Private EXCLUI			:= nOpc == 5	
    Private nOpc			:= nOpc

    if Type('aCabecAuto') <> 'U' .AND. INCLUI
       lAuto	:= .T.
    endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Inicializa as variaveis, estas variaveis indicarao quais tabelas ³
	//³serao demonstradas                                               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Eh rodada a funcao de inicializacao das variaveis do modeloaba,    ³
	//³eh necessario esta 'reinicializacao' a cada chamada do modeloaba   ³
	//³pois havia casos em que abriamos um modelo aba e depois abriamos   ³
	//³um novo mbrowse, este por sua vez com outro modelo aba, dai        ³
	//³quando voltavamos para o primeiro as variaveis haviam sido perdidas³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	if Upper(Left(cFunVars,2)) == 'U_'
		cFunVars	:= SubStr(cFunVars, 3, len(cFunction) - 2)
	endif
	if ExistBlock(cFunVars)
		aPrivates	:= u_modeloaba(1)
		for i:= 1 to len(aPrivates)
			&(aPrivates[i][1])	:= &(aPrivates[i][2])
		next
		ExecBlock(cFunVars,.F.,.F.)
	else 
		MsgInfo("Função de inicialização de variáveis não encontrada","Aviso")
	endif
   
	nRecNoCabec		:= (cCabec)->(RecNo())

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³O nOpc = 9 significa que deve ser rodada a funcao de replica das    ³
	//³tabelas constantes no modeloaba, para a replica funcionar devem ser ³
	//³corretamente configuradas as variaveis e criadas as tabelas de copia³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	if nOpc == 9
		if ReplicaCampos()
			Return .T.
		else
			Return .F.
		endif
	endif                                  
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Faz validacoes simples nos arrays do modeloaba, validacoes de estrutura/preenchimento dos arrays ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	if !VldArray()
		Return
	endif


	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Ponto de entrada executado 'antes de tudo', serve como validacao³
	//³de pre entrada, requer retorno logico                           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	if ExistPe('AntesDeTudo')
		lAntesDeTudo	:= ExecPe('AntesDeTudo', 'L')
		if !lAntesDeTudo
			Return .F.		
		endif
	endif
	lResult		:= .F.

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³nOpc          ³
	//³2 - Visualizar³
	//³3 - Incluir   ³
	//³4 - Alterar   ³
	//³5 - Excluir   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Ja exisitia a chamada aqui porem nao era utilizada, entao coloquei no ³
	//³dialog para pegar do array, para ficar o tamanho completo da tela     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aSize := MsAdvSize()

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Cria o dialogo³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	if !lAuto
		oDlg	:= MSDialog():New(aSize[1],aSize[1],aSize[6],aSize[5],cTitulo,,,,,CLR_BLACK,CLR_WHITE,,,.t.)
	
	//Necessário pois a dialog deve ser ativada (quando não, e ocorre várias chamadas do modeloAba, ocorre overflow)
	//Deixa o tamanho 1,1,1,1 para a tela não ficar visível após a ativação
	else
		oDlg	:= tDialog():New(1,1,1,1,'Gravando...',,,,,CLR_BLACK,CLR_WHITE,,,.t.)	
	endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Cria o Splitter³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	oSplitter := tSplitter():New( 30,30,oDlg,01,01,1)
	oSplitter:Align	:= CONTROL_ALIGN_ALLCLIENT


	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Ponto de entrada executado 'antes de tudo', serve como validacao³
	//³de pre entrada, requer retorno logico                           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	if ExistPe('TamanhoCabec')
		nTamCabec	:= ExecPe('TamanhoCabec', 'N')
	Else
		nTamCabec	:= 100
	endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Ponto de entrada executado 'antes de tudo', serve para mostrar  ³
	//³apenas os campos passado por parametro e não mais do SX3.       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	if ExistPe('YesFieldsCabec')
		aField	:= ExecPe('YesFieldsCabec', 'A')
	endif

	lCreate	:= .F.
	if ExistPe('YesFolderCabec')
		aFolder	:= ExecPe('YesFolderCabec', 'A')
		lCreate	:= .T.
	endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Cria os dois Panels³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	oPanelCabec	:= tPanel():New(30,30,"",oSplitter,,,,,CLR_BLUE,100,nTamCabec) // cria o painel
	oPanelCabec:Align := CONTROL_ALIGN_TOP        

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¸
	//³Cria a Enchoice³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	RegToMemory(cCabec,INCLUI)

	oEnchoice	:= Msmget():New(cCabec, (cCabec)->(RecNo()), nOpc,,,,aAcho			 ,{(20),(1),(120),(400)}	, aAcho, 3,,,,oPanelCabec,, .T., , , , ,aField,aFolder,)

	oEnchoice:oBox:Align := CONTROL_ALIGN_ALLCLIENT
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Da o foco no primeiro dos campos 'focaveis' do enchoice³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
//	SX3->(dbSetOrder(2))
 
    oSXS:cEmpresa := cEmpAnt              // Montar a empresa
    oSXS:cSXS     := "SX3"                // Tabela da SXS

	for i:= 1 to len(aGets)                            
		cCampo	     := SubStr(aGets[i],9,10) 
        oSXS:cTabela := Substr(cCampo,1,3)   // Tabela que quer pegar a estrutura
        aCpoEnchoice := oSXS:Montar()

        For nId := 1 To Len(aCpoEnchoice)
            If AllTrim(aCpoEnchoice[nId][02]) == AllTrim(cCampo) .and.;
			   aCpoEnchoice[nId][15] == 'A' .and. X3USO(aCpoEnchoice[nId][07]) .and.;
			   aCpoEnchoice[nId][11] == 'R' .and. Empty(aCpoEnchoice[nId][12])
   			   If Type("oEnchoice:aEntryCtrls[i]:oGet") <> 'U'
				  oEnchoice:aEntryCtrls[i]:oGet:SetFocus()							
				  Exit
			   EndIf
			EndIf   
        Next

//		if SX3->(dbSeek(cCampo)) .and. SX3->X3_VISUAL == 'A' .AND. X3USO(SX3->X3_USADO) .AND. SX3->X3_CONTEXT == 'R' .AND. EMPTY(SX3->X3_CBOX)
//			If Type("oEnchoice:aEntryCtrls[i]:oGet") <> 'U'
//				oEnchoice:aEntryCtrls[i]:oGet:SetFocus()							
//				Exit
//			EndIf
//		endif
	next

 
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Cria Folders³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÙ	
	aTFolder	:= {}
	for i:= 1 to len(aNomes)
		if !'&' $ aNomes[i]
			aNomes[i]	:= '&' + aNomes[i]
		endif
		aAdd(aTFolder,aNomes[i])
	next
	
	oTFolder := TFolder():New( 0,0,aTFolder,,/*oPanelItens*/oSplitter,,,,.T.,,260,184 )
	oTFolder:Align			:= CONTROL_ALIGN_ALLCLIENT

	oTFolder:bChange		:= {|| OnChangeAba() }


	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Cria a  grid dentro dos folders³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	for i:= 1 to len(aFilhas)

		cLinOk	:= nil
		if ExistPe('LinOk'+StrZero(i,2))
			cLinOk	:= ExecPe('LinOk'+StrZero(i,2), 'C')
		endif

		if ExistPe('LinOk'+aFilhas[i])
			cLinOk	:= ExecPe('LinOk'+aFilhas[i], 'C')
		endif

		cDelOk	:= "iif(lAutoDel, .t., u_DelCDom())"
		if ExistPe('DelOk'+StrZero(i,2))
			cDelOk	+= iif(!Empty(cDelOk),' .AND. ','') + ExecPe('DelOk'+StrZero(i,2), 'C')
		endif	
		if ExistPe('DelOk'+aFilhas[i])
			cDelOk	+= iif(!Empty(cDelOk),' .AND. ','') + ExecPe('DelOk'+aFilhas[i], 'C')
		endif			                                                 
		
		cTudoOk	:= nil
		if ExistPe('TudoOk'+StrZero(i,2))
			cTudoOk	:= ExecPe('TudoOk'+StrZero(i,2), 'C')
		endif
		
		//ÚÄÄÄÄÄÄÄÄÄ¿
		//³Variaveis³
		//ÀÄÄÄÄÄÄÄÄÄÙ
		cHeader			:= 'aHeader' 	+ StrZero(i,2)
		cCols				:= 'aCols' 		+ StrZero(i,2)
		cGetDados		:= 'oGet' 		+ StrZero(i,2)
		cLimpo			:= 'aLimpo'		+ StrZero(i,2)
		aHeader			:= {}
		aCols				:= {}
		nPosCampoIni	:= 0
		cSeekAux			:= &(_aSeek[i])
		aNoFields		:= nil
		aYesFields		:= nil
		cAliasCampo		:= iif(Left(aFilhas[i],1)=='S', Right(aFilhas[i],2), aFilhas[i])

 		if ExistPe('NoFields'+StrZero(i,2)) 
 			aNoFields	:= ExecPe('NoFields' +StrZero(i,2), 'A')
  		endif

 		if ExistPe('NoFields'+aFilhas[i]) 
 			aNoFields	:= ExecPe('NoFields' +  aFilhas[i], 'A')
  		endif

 		if ExistPe('YesFields'+StrZero(i,2)) 
 			aYesFields	:= ExecPe('YesFields'+StrZero(i,2), 'A')
  		endif  

 		if ExistPe('YesFields'+aFilhas[i]) 
 			aYesFields	:= ExecPe('YesFields'+  aFilhas[i], 'A')
  		endif    

 		if ExistPe('OnlyYes'+StrZero(i,2)) 
 			lOnlyYes		:= ExecPe('OnlyYes'  +StrZero(i,2), 'L')
  		endif  

 		if ExistPe('OnlyYes'+aFilhas[i]) 
 			lOnlyYes		:= ExecPe('OnlyYes'		+ aFilhas[i], 'L')
  		endif    

 		if ExistPe('UserFields'+StrZero(i,2)) 
 			lUserFields	:= ExecPe('UserFields'	+ StrZero(i,2), 'L')
  		endif

		if ExistPe('UserFields'+aFilhas[i]) 
 			lUserFields	:= ExecPe('UserFields'	+ aFilhas[i], 'L')
  		endif
  		
 		if ExistPe('YesUsado'+StrZero(i,2)) 
 			aYesFields	:= ExecPe('YesUsado'		+ StrZero(i,2), 'A')
  		endif  

 		if ExistPe('YesUsado'+aFilhas[i]) 
 			aYesFields	:= ExecPe('YesUsado'		+ aFilhas[i], 'A')
  		endif    

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Ponto de entrada utilizado para preencher o aCols com os dados³
		//³de uma query ao inves de utilizar os dados da tabela.         ³
		//³Esta query tem de ter os campos do alias, sem 'inners'.       ³		
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
  		cFiltroQuery	:= ''
 		if ExistPe('FiltroQuery'+StrZero(i,2))
 			cFiltroQuery:= ExecPe('FiltroQuery'+StrZero(i,2), 'C')
  		endif

 		if ExistPe('FiltroQuery'+aFilhas[i])
 			cFiltroQuery:= ExecPe('FiltroQuery'+aFilhas[i], 'C')
  		endif  		

   	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Cria o aHeader e o aCols ja com os dados³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		FillGetDados(nOpc,aFilhas[i],aOrdem[i],cSeekAux,aWhile[i],/*{{bCond,bAction1,bAction2}}*/,aNoFields,aYesFields,lOnlyYes,cFiltroQuery,/*bMontCols*/,INCLUI,/*aHeaderAux*/,/*aColsAux*/,/*bafterCols*/,/*bBeforeCols*/,/*bAfterHeader*/,/*cAliasQry*/,iif(aReadOnly[i],{|| ''},nil), lUserFields, aYesUsado)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Ponto de entrada chamado imediatamente apos o preenchimento do aHeader e aCols.³
		//³Serve para fazer quaisquer modificacoes no aHeader e no aCols                  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		if ExistPe('AfterFillGetDados'+StrZero(i,2)) 
			ExecPe('AfterFillGetDados'+StrZero(i,2), 'N')
		endif

		if ExistPe('AfterFillGetDados') 
			ExecPe('AfterFillGetDados', 'N')
		endif		
		aAuxAHeader	:= {}
 		if ExistPe('ChangeDescAHeader'+StrZero(i,2)) 
 			aAuxAHeader	:= ExecPe('ChangeDescAHeader'+StrZero(i,2), 'A')
 		endif

 		if ExistPe('ChangeDescAHeader'+aFilhas[i]) 
 			aAuxAHeader	:= ExecPe('ChangeDescAHeader'+aFilhas[i], 'A')
 		endif 		

 		if len(aAuxAHeader) > 0
 			for a:= 1 to len(aAuxAHeader)
 				nPosAux	:= aScan(aHeader, {|aX| AllTrim(Upper(aX[2])) == AllTrim(Upper(aAuxAHeader[a][2]))})
 				if nPosAux <> 0
 					aHeader[nPosAux][1]	:= aAuxAHeader[a][1]
 				endif
 			next
  		endif
  		
  		

		_cTabela	:= aFilhas[i]                     
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Verifica se a tabela eh contradominio de alguma outra tabela³
		//³Se for, preenche inicializador padrao, normalmente eh o     ³
		//³campo XX_SEQ, mas podem ser outros, este campo tera iniciali³				
		//³zador padrao o XX_SEQ da tabela dominio.                    ³		
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
/*		nPosFil	:= aScan(aFiltro, {|aX| Upper(aX[2]) == Upper(_cTabela)})
		nPosIniPad	:= 9
		if nPosFil > 0
			aCamposFil	:= aClone(aFiltro[nPosFil][3])
			for y := 1 to len(aCamposFil)	
				cCampoDom	 := aCamposFil[y][1]
				nPosFilDom	 := aScan(aFilhas, {|aX| Upper(aX) == Upper(aFiltro[nPosFil][1])})
   			    cHeaderDom	 := 'aHeader' + StrZero(nPosFilDom,2)
				cGetDom		 := 'oGet'+StrZero(nPosFilDom,2)
				nPosCampoDom := GdFieldPos(cCampoDom, &(cHeaderDom))
				cCampoCdom	 := aCamposFil[y][2]
				cInicPad	 := "GDFieldGet('" + cCampoDom 	+ "'," 
				cInicPad	 += "" + cGetDom + ":nAt" + ",,"
				cInicPad	 += "" + cGetDom + ":aHeader" + ","
				cInicPad	 += "" + cGetDom + ":aCols)"
				SX3->(dbSetOrder(2))
				if SX3->(dbSeek(cCampoCdom))
					if aReadOnly[i] == .F.
						RecLock('SX3', .F.)
							SX3->X3_RELACAO	:= cInicPad//"u_InicPad(cInicPad)"
							SX3->X3_VISUAL	:= 'V'
						SX3->(msUnLock())
					endif
				endif
			next
		endif
*/
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Se houver campo sequencial no get (tipo o campo 'sequencial' dos itens³
		//³do venda assistida) entao inicializa este campo                       ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		if Len(aIniPos) <> 0 .and. aIniPos[i] <> nil .and. !Empty(aIniPos[i])
			nPosCampoIni	:= GdFieldPos(Right(aIniPos[i],len(aIniPos[i])-1))
			if nPosCampoIni > 0 .and. Empty(aCols[1][nPosCampoIni]) .AND. !aReadOnly[i]
				aCols[1][nPosCampoIni]	:= StrZero(1,len(aCols[1][nPosCampoIni]))
			endif
		endif

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Clona o aHeader e o aCols que foi gerado pelo FillGetDados        ³
		//³Dai teremos o aHeader01, 02... tem de clonar porque tem mais de um³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		&(cHeader)		:= aClone(aHeader)
		&(cCols)			:= aClone(aCols)
		n           	:= len(&(cCols))
		nOperacao 		:= Iif(INCLUI .Or. ALTERA, GD_INSERT+GD_UPDATE+GD_DELETE, 0)

		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Se a filha for definida como read only, esta filha nao podera ser editada³
		//³e nem sera gravada no OK da tela, ou seja, serao so demonstrados os dados³
		//³e nao serao gravados                                                     ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		if aReadOnly[i]
			nOperacao 		:= 0
  		endif
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Ponto de entrada para manipular  a operacao, fiz pois necessitei³
		//³que fossse apenas GD_UPDATE na grid, entao se deseja usar       ³
		//³so um tipo de operacao ou manipula o tipo use esse PE           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		if ExistPe('TipoOperacao'+StrZero(i,2))
			nOperacao := ExecPe('TipoOperacao'+StrZero(i,2), 'N')
		endif
		
		if ExistPe('TipoOperacao'+aFilhas[i])
			nOperacao := ExecPe('TipoOperacao'+aFilhas[i], 'N')
		endif		

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Cria a funcao de change de item dos grids ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		bChange			:= {||OnChange()}

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Cria um texto padrao que ficara atras das grids, quando as mesmas ³
		//³nao aparecerem apararecera o texto 'nao ha itens'                 ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		oFont 			:= TFont():New('Courier new',,-18,.T.)
      oSay				:= TSay():New(01,01,{||'Não há itens'},oTFolder:aDialogs[i],,oFont,,,,.T.,CLR_RED,CLR_WHITE,200,20)

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Cria a quantidade maxima de registros que uma grid pode ter³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nMaxLinhas	:= 9999
		if ExistPe('MaxLinhas'+StrZero(i,2))
			nMaxLinhas	:= ExecPe('MaxLinhas'+StrZero(i,2), 'N')
		endif
		
		if ExistPe('MaxLinhas'+aFilhas[i])
			nMaxLinhas	:= ExecPe('MaxLinhas'+aFilhas[i], 'N')
		endif		

		nFreeze	:= 0
		if ExistPe('Freeze'+StrZero(i,2))
			nFreeze	:= ExecPe('Freeze'+StrZero(i,2), 'N')
		endif
		
		aAlter	:= nil
		if ExistPe('CamposAlteraveis'+StrZero(i,2))
			aAlter	:= ExecPe('CamposAlteraveis'+StrZero(i,2), 'A')
		endif		

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Cria o newgetdados³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		&(cGetDados) 	:= MsNewGetDados():New(15,1,20,40,nOperacao,cLinOK,cTudoOk,aIniPos[i],aAlter,nFreeze,nMaxLinhas,,,cDelOK,oTFolder:aDialogs[i], &(cHeader), &(cCols), bChange)
		         
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Ponto de entrada que adiciona acoes em campos da grid.   ³
		//³http://tdn.totvs.com/display/softwaregestao/MsNewGetDados³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		aAddAction	:= {}
		if ExistPe('AddAction'+StrZero(i,2))
			aAddAction	:= ExecPe('AddAction'+StrZero(i,2), 'A')
		endif			 
		
		for z:= 1 to len(aAddAction)
			&(cGetDados):AddAction(aAddAction[z][1], aAddAction[z][2])
		next
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Ponto de entrada para setar a funcao que muda as linhas de uma grid ³
		//³se baseando em alguma condicao                                      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nPosFil	:= aScan(aFiltro, {|aX| Upper(aX[2]) == Upper(aFilhas[i])}) 

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³so tera cores se nao for uma grid filtrada, a filtrada estava dando errro. ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		if ExistPE('CorLinhasAba'+StrZero(i, 2)) .AND. nPosFil == 0
			/*
			#define CLR_BLACK             0               // RGB(   0,   0,   0 )
			#define CLR_BLUE        8388608               // RGB(   0,   0, 128 )
			#define CLR_GREEN         32768               // RGB(   0, 128,   0 )
			#define CLR_CYAN        8421376               // RGB(   0, 128, 128 )
			#define CLR_RED             128               // RGB( 128,   0,   0 )
			#define CLR_MAGENTA     8388736               // RGB( 128,   0, 128 )
			#define CLR_BROWN         32896               // RGB( 128, 128,   0 )
			#define CLR_HGRAY      12632256               // RGB( 192, 192, 192 )
			#define CLR_LIGHTGRAY  CLR_HGRAY
			
			//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ//
			//                       High Intensity Colors
			//ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ//
			
			#define CLR_GRAY        8421504               // RGB( 128, 128, 128 )
			#define CLR_HBLUE      16711680               // RGB(   0,   0, 255 )
			#define CLR_HGREEN        65280               // RGB(   0, 255,   0 )
			#define CLR_HCYAN      16776960               // RGB(   0, 255, 255 )
			#define CLR_HRED            255               // RGB( 255,   0,   0 )
			#define CLR_HMAGENTA   16711935               // RGB( 255,   0, 255 )
			#define CLR_YELLOW        65535               // RGB( 255, 255,   0 )
			#define CLR_WHITE      16777215               // RGB( 255, 255, 255 )
			*/
			&(cGetDados):oBrowse:lUseDefaultColors := .F.
			bColorsAux	:= ExecPE('CorLinhasAba'+StrZero(i, 2), 'B')
			&(cGetDados):oBrowse:SetBlkBackColor(bColorsAux)
		endif		                               
		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Alinha o get dados para preencher o panel todo³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		&(cGetDados):oBrowse:Align := CONTROL_ALIGN_ALLCLIENT
		&(cGetDados):ForceRefresh()                               
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³ Se esta incluindo, e o get tem Dominio, apaga a linha, para evitar validacoes³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		nPosREC := aScan(&(cGetDados):aHeader, {|x| x[1] == "Recno WT" })
		
		if (INCLUI .AND. TemDomCdom(&(cGetDados):aHeader[1][2], 2) > 0) .OR. (ALTERA .AND. nPosRec > 0 .AND. Len(&(cGetDados):aCols) == 1 .AND. &(cGetDados):aCols[1][nPosRec] == 0) 
			lAutoDel	:= .T.
			&(cGetDados):DelLine(1)
			lAutoDel	:= .F.
		endif
	next
	lResult		:= .F.
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Ponto de entrada para incluir botoes no modelo aba, nao eh permitido                                                ³
	//³chamar novos browses que tenham modeloaba a partir destes botoes                                                    ³
	//³Aadd( aButtons, {"HISTORIC", {|| ApMsgInfo('Colocar Botao (AddButton)')}, "Histórico...", "Histórico" , {|| .T.}} ) ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	if ExistPE('AddButton')
		aButtons	:= ExecPe('AddButton', 'A')
	endif
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se for copia, inicializa os campos que devem ser 'refreshados' como normalmente eh o campo codigo.³
	//³E altera as variaveis de controle de alteracao, e inclusao                                        ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	if lCopia
		for u:= 1 to len(aFieldsCopia)
			&(aFieldsCopia[u][1])	:= &(aFieldsCopia[u][2])
		next
		INCLUI			:= .T.
		ALTERA			:= .F.
		nRecNoCabec		:= 0
		GetDRefresh()
	endif     
	
	if ExistPE('AntesAtvDlg')
		ExecPe('AntesAtvDlg', 'L')
	endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Ativa o Dialogo³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	if !lAuto
		oDlg:bInit := {|| EnchoiceBar(oDlg, {||lResult := TudoOk(), iif(lResult, oDlg:End(), lResult := .F.)},{||lResult:=.F.,oDlg:End()},,@aButtons)}	
		oDlg:lCentered := .T.	
		oDlg:Activate()
	endif

	begin sequence

	//ExecAuto do modeloAba	
	if lAuto .and. len(aDados) >= 1

		lResult		:= .T.
		
		//Grava o cabeçalho (enchoice)
		aCabecAuto	:= aClone(aDados[1])
		
		for i := 1 to len(aCabecAuto)

			//preenche os campos em memória para compatabilização 		
			cCampo		:= aCabecAuto[i][1]
			__ReadVar	:= 'M->' + cCampo
			M->&(cCampo):= aCabecAuto[i][2]

			oSXS:cEmpresa := cEmpAnt              // Montar a empresa
            oSXS:cSXS     := "SX3"                // Tabela da SXS
            oSXS:cTabela  := Substr(cCampo,1,3)   // Tabela que quer pegar a estrutura
    
	        aCpoEnchoice := oSXS:Montar()

            For nId := 1 To Len(aCpoEnchoice)
			   // Executa validações do sistema
				If ! Empty(aCpoEnchoice[nId][06]) .and. !&(allTrim(aCpoEnchoice[nId][06]))  // SX3->X3_VALID
				   MsgInfo("Campo não foi validado: " + aCpoEnchoice[nId][02] + ": " +;
				           M->&(aCpoEnchoice[nId][02]),"ExecAuto ModeloAba")
		  		   break
			 	EndIf

			   // Executa validações de usuário			 
			 	If ! Empty(aCpoEnchoice[nId][16]) .and. !&(allTrim(aCpoEnchoice[nId][16]))
					MsgInfo("Campo não foi validado: " + aCpoEnchoice[nId][02] + ": " +;
					        M->&(aCpoEnchoice[nId][02]),"ExecAuto ModeloAba")
			 		break
			 	EndIf				 
            Next

/*			if SX3->(dbSeek(cCampo)) 
				//executa validações do sistema
				if !empty(SX3->X3_VALID) .and. !&(allTrim(SX3->X3_VALID))
					MsgInfo("Campo não foi validado: " + SX3->X3_CAMPO + ": " + M->&(cCampo),"ExecAuto ModeloAba")
		  			break
			 	endif
			 	
				//executa validações de usuário			 
			 	if !empty(SX3->X3_VLDUSER) .and. !&(allTrim(SX3->X3_VLDUSER))
					MsgInfo("Campo não foi validado: " + SX3->X3_CAMPO + ": " + M->&(cCampo),"ExecAuto ModeloAba")
			 		break
			 	endif
			endif
*/
			//executa trigger do campo (tipo 1-enchoice)
			if existTrigger(cCampo)
				runTrigger(1, , , , allTrim(cCampo))
			endif    			
		next
		
		//Grava as tabelas filhas (GetDados) 
		for j := 2 to len(aDados)
		
			aItensAuto := aClone(aDados[j])
			
			for i := 1 to len(aItensAuto)
				
				if i <> 1
					oGetTemp:AddLine(.T.)
				endif
			
				oGetTemp	:= &('oGet' + strZero(j-1,2))
				aCols			:= oGetTemp:aCols
				aHeader		:= oGetTemp:aHeader
							
				for t := 1 to len(aItensAuto[i])
					
					//preenche os campos em memória para compatabilização 
					cCampo		:= aItensAuto[i][t][1]
					__ReadVar	:= 'M->' + cCampo																			
					GdFieldPut(aItensAuto[i][t][1], aItensAuto[i][t][2], i, oGetTemp:aHeader, oGetTemp:aCols)
					M->&(cCampo) := GdFieldGet(cCampo, i, .F., oGetTemp:aHeader, oGetTemp:aCols)
                    oSXS:cTabela := Substr(cCampo,1,3)   // Tabela que quer pegar a estrutura
    
                    aCpoEnchoice := oSXS:Montar()

                    For nId := 1 To Len(aCpoEnchoice)
			          // Executa validações do sistema
			           If ! Empty(aCpoEnchoice[nId][06]) .and. !&(allTrim(aCpoEnchoice[nId][06]))  // SX3->X3_VALID
				          MsgInfo("Campo não foi validado: " + aCpoEnchoice[nId][02] + ": " +;
				                   M->&(aCpoEnchoice[nId][02]),"ExecAuto ModeloAba")
		  		          break
			 	       EndIf

			          // Executa validações de usuário			 
			 	       If ! Empty(aCpoEnchoice[nId][16]) .and. !&(allTrim(aCpoEnchoice[nId][16]))
					      MsgInfo("Campo não foi validado: " + aCpoEnchoice[nId][02] + ": " +;
					               M->&(aCpoEnchoice[nId][02]),"ExecAuto ModeloAba")
			 		      break
			 	       EndIf				 
                    Next

/*					if SX3->(dbSeek(cCampo)) 
						//executa as validações do sistema
						if !empty(SX3->X3_VALID) .and. !&(allTrim(SX3->X3_VALID))
							MsgInfo("Campo não foi validado: " + SX3->X3_CAMPO + ": " + M->&(cCampo),"ExecAuto ModeloAba")
							break
					 	endif
					 	
					 	//executa as validações de usuário
					 	if !empty(SX3->X3_VLDUSER) .and. !&(allTrim(SX3->X3_VLDUSER))
							MsgInfo("Campo não foi validado: " + SX3->X3_CAMPO + ": " + M->&(cCampo),"ExecAuto ModeloAba")
					 		break
					 	endif
					endif
*/					       
					//Executa gatilho (tipo 2-getdados)
					//[ nTipo: 1 - Enchoice; 2 - getDados ] [ nLin - linha do getDados ] [ cMacro - n usado ] [ oObj - objeto do Get] [ cField ]
					runTrigger(2, I, , , allTrim(cCampo))
				next
			next
		next
		
		//Validação do tudoOk						
		if !TudoOk()
			break
		endif
	endif
	
	recover 
	
	lResult := .F.
	
   end sequence

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Gravacao dos dados    ³
	//³Da enchoice e das abas³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	if lResult .AND. !VISUAL
		begin Transaction

			if ExistPe('BeforePost')
				lResult	:= ExecPe('BeforePost', 'L')
				if !lResult
					DisarmTransaction()
				endif
			endif

			if lResult .AND. INCLUI
				ConfirmSX8()
			else 
				RollBackSX8()
			endif           
			
			if lResult    
				GrvCabec()     

				if ExistPe('AfterPostCabec')
					ExecPe('AfterPostCabec', 'L')
				endif
	
				for i:= 1 to len(aFilhas)
					if aReadOnly[i] == .F.
						u_GrvItens(i)
					endif
				next
	
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Ponto de entrada executado apos a gravacao de tudo, ³
				//³e antes do commit da transacao, se retornar false a ³
				//³transacao eh rollbackada                            ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				if ExistPe('AfterPost')
					if !ExecPe('AfterPost', 'L')
						DisarmTransaction()
					endif
				endif
			endif

		end Transaction
	else
		if INCLUI
			if ExistPe('ConfirmSX8NoCancelamento') .and. ExecPe('ConfirmSX8NoCancelamento', 'L')
				ConfirmSX8()
			else
				RollBackSX8()
			endif
		endif
	endif
	
 	if lAuto .AND. !lResult
		for nI:= 1 to len(aDados)
			u_Aviso('', Replicate('-', 40))
			u_Aviso('', iif(nI==1, 'Cabeçalho', aNomes[nI]))
			u_Aviso('', Replicate('-', 40))
			for nX:= 1 to len(aDados[nI])
				if nI == 1
					u_Aviso('', aDados[nI][nX][1] + ' := ' + cValToChar(aDados[nI][nX][2]))
				else
					for nT := 1 to len(aDados[nI][nX])
						u_Aviso('', aDados[nI][nX][nT][1] + ' := ' + cValToChar(aDados[nI][nX][nT][2]))
					next
				endif
			next
		next
		u_Aviso('', '')
		u_Aviso('', '')		
		u_Aviso('', '')		
	endif
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Ponto de entrada executado apos as gravacoes, depois do commit³
	//³da transacao. Sera normalmente utilizado para contabilizacoes ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	if ExistPe('DepoisDeTudo')
		ExecPe('DepoisDeTudo', 'L')
	endif      

	//Necessário para compatibilização - a Dialog aberta sem ser ativada e devidamente fechada ocasionava overflow
	if lAuto  		
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Abre e fecha a tela, tiramos o freeobj pois so dando o freeobj ele trava o rpo³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		oDlg:Activate(,,,.T.,{|| oDlg:End(),.T.},,{|| oDlg:End()} )
//		freeObj(oDlg)
	endif

Return lResult

//ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
//±±ºPrograma  ³GrvCabec  ºAutor  ³George Allan        º Data ³  01/09/10   º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºDesc.     ³Funcao que grava o conteudo do cabecalho do modeloaba       º±±
//±±º          ³                                                            º±±
//±±º          ³                                                            º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºUso       ³                                                            º±±
//±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß

Static Function GrvCabec()
	local i   
	local lResult
	local nTamAlias
	if !INCLUI
		(cCabec)->(dbGoTo(nRecNoCabec))
	endif

	RecLock((cCabec),INCLUI)	
		If DELETA
			(cCabec)->(dbDelete())
		Else           
			nTamAlias	:= iif(left(cCabec,1)<> 'S',3,2)
			(cCabec)->&(Right(cCabec,nTamAlias)+'_FILIAL')	:= xFilial(cCabec)
			for i:= 1 to len(aGets)
				cCampo	:= SubStr(aGets[i],9,10)
				(cCabec)->&(cCampo)	:= M->&(cCampo)
			next
		EndIf

	(cCabec)->(MsUnLock())

Return
//ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
//±±ºPrograma  ³GrvItens  ºAutor  ³George Allan        º Data ³  01/09/10   º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºDesc.     ³Funcao de gravacao das tabelas itens do modeloaba           º±±
//±±º          ³                                                            º±±
//±±º          ³                                                            º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºUso       ³                                                            º±±
//±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß

User Function GrvItens(nItem)
	local i, j
	local lResult   	           
	local cItem
	local cAlias		:= aFilhas[nItem]
	local _aSeekItens	:= _aChave[nItem]
	local cCols			:= 'aCols'	+ StrZero(nItem,02)
	local cHeader		:= 'aHeader'+ StrZero(nItem,02)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Preenche o aHeader e o aCols pois o GDGetField funciona so           ³
	//³se eles estiverem preenchidos, tipo, nao tem como chamar o GDGetField³
	//³se estivermos utilizando um array aHeader01 ou aCols01               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cGetDados 			:= "oGet" + StrZero(nItem, 2)
	cGet		 			:= "oGet" + StrZero(nItem, 2)	
	aHeader 				:= aClone(&(cGetDados):aHeader)
	aCols   				:= aClone(&(cGetDados):aCols)
	n 						:= &(cGetDados):nAt

	(cAlias)->(dbSetOrder(aOrdItem[nItem]))
	if ExistPe('BeforePostItem')
		ExecPe('BeforePostItem', 'L')
	endif                     
	aHeader 				:= aClone(&(cGetDados):aHeader)
	aCols   				:= aClone(&(cGetDados):aCols)

	for i:= 1 to len(aCols)
		n 					:= i
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Monta a chave de pesquisa de existencia³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		cSeek	:= ''
//		oError := ErrorBlock({|e|MsgAlert("(" + cAlias + ") PREENCHA CORRETAMENTE O ARRAY aLinha e o ARRAY aOrdItem" +chr(10)+ e:Description)}) 

		for j:= 1 to len(_aSeekItens)
			cSeek	+= &(_aSeekItens[j][2])
		next

  //		ErrorBlock(oErro)
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Se nao encontrar o registro e estiver deletado no aCols³
		//³Basta ignorar a linha                                  ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		if !(cAlias)->(dbSeek(cSeek)) .and. aCols[i][Len(aHeader) + 1]
			LOOP
		endif
		RecLock(cAlias,!(cAlias)->(Found()))

			if (cAlias)->(Found()) .And. (aCols[i][Len(aHeader) + 1] .OR. DELETA )
				(cAlias)->(dbDelete())
			else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Grava os campos que estao na grid (aCols)³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
				for j:= 1 to len(aHeader)
					(cAlias)->&(aHeader[j][2])	:= GDFieldGet(aHeader[j][2],i)
				next
				//# ver virtual, gravacao, pau
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Grava os campos que sao chave, e podem nao estar no aCols³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

				for j:= 1 to len(_aSeekItens)                                    
			  /*		cCampo1		:= _aSeekItens[j][1]
					cCampo2		:= _aSeekItens[j][1]
					cTamCampo1	:= StrZero(len(&(cCampo1)),3)
					cTamCampo2	:= StrZero(len(&(cCampo1)),3)
					if cTamCampo1 <> cTamCampo2
						ApMsgInfo('O campo ' + cCampo1 + ' tem tamanho diferente de '  + cCampo2 + chr(13) + chr(10);
									+	' ajuste os campos para a gravacao ficar correta.' + chr(13) + chr(10);
									+ cCampo1 + ' Tamanho: ' + cTamCampo1 + chr(13) + chr(10);
									+ cCampo2 + ' Tamanho: ' + cTamCampo2 )
					endif*/
					&(_aSeekItens[j][1])	:= &(_aSeekItens[j][2])
				next                                                         
			endIf
		(cAlias)->(MsUnLock())
		if ExistPe('AfterPostItem')
			ExecPe('AfterPostItem', 'L')
		endif
	next
Return

                             
//ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
//±±ºPrograma  ³ExistPe   ºAutor  ³George Allan        º Data ³  13/09/10   º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºDesc.     ³Funcao que verifica se existe o ponto de entrada passado    º±±
//±±º          ³pelo parametro                                              º±±
//±±º          ³                                                            º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºUso       ³                                                            º±±
//±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
Static Function ExistPe(cPe)
	local lResult	:= .F.
	nPos		:= aScan(aPE, {|aX| Upper(aX[1]) == Upper(cPe)})
	if nPos	> 0
		lResult	:= .T.
	endif
Return lResult

//ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
//±±ºPrograma  ³ExecPe    ºAutor  ³George Allan        º Data ³  01/09/10   º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºDesc.     ³Funcao que executa o ponto de entrada, so deve ser chamada  º±±
//±±º          ³se o ExistPe tambem retornar .t.                            º±±
//±±º          ³                                                            º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºUso       ³                                                            º±±
//±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
Static Function ExecPe(cPe, cTipo)
	local xResult	:= ''
	nPos		:= aScan(aPE, {|aX| Upper(aX[1]) == Upper(cPe)})
	if nPos	> 0
		xResult	:= aPE[nPos][2]
	endif      

	xResult	:= &(xResult)

	if Upper(ValType(xResult)) <> Upper(cTipo)
       MsgInfo("PE: " + cPe + " com retorno ou tipo inválido. Retorno: " + ValType(xResult) + ". retorno esperado" + cTipo,"Aviso")
	endif                                                     
	
Return xResult

//ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
//±±ºPrograma  ³TudoOk    ºAutor  ³George Allan        º Data ³  01/09/10   º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºDesc.     ³Funcao de validacao geral da tela                           º±±
//±±º          ³Valida campos obrigadorios do enchoice, dos gets e executa  º±±
//±±º          ³pontos de entrada, eh executado antes da gravacao dos dados º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºUso       ³                                                            º±±
//±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß

Static Function TudoOk()
	local i    
	local lResult := .T.
	local _aColsAux	:= {}
	local _aColsAux	:= {}
	local oGetTmp
	
	if ExistPe('BeforeTudoOk')
		lBeforeTudoOk	:= ExecPe('BeforeTudoOk', 'L')
		lResult			:= lBeforeTudoOk
	endif	

	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Valida os campos obrigatorios³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	if lResult
		for i:= 1 to len(aGets)                            
			cCampo	:= SubStr(aGets[i],9,10) 
			cConteudo:= &('M->'+ cCampo)
			dbSelectArea('SX3')
			if lResult .AND. X3Obrigat(SubStr(aGets[i],9,10)) .AND. Empty(cConteudo)
				// antes de dar o foco eh para verificar se o campo pode ser focado, tipo... se ele esta bulível
				oEnchoice:aEntryCtrls[i]:SetFocus()
//				Help(" ",1,"OBRIGAT",,Padr(RetTitle(cCampo),40),3)
				MsgInfo("Campo obrigatório não preenchido " + AllTrim(RetTitle(cCampo)) + "(" + AllTrim(cCampo) + ")","Aviso")
				lResult	:= .F.
			endif
		next
	endif
	
	if lResult

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³valida campos de cada pasta: se der erro mostra a pasta onde esta o erro³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		for i := 1 To Len(oTFolder:aDialogs)
		    alert("entrei")
			cGetDados	:= "oGet" + StrZero(i, 2)
			oGetTmp		:= &(cGetDados)
			oGetTmp:OnChange() 
			aAdd(_aColsAux, aClone(oGetTmp:aCols))
			if !oGetTmp:ChkObrigat(oGetTmp:nAt)
				oTFolder:nOption 	:= i //oTFolder:SetOption(2)
				lResult				:= .F.
				exit
			endif
			if !eval(oGetTmp:bTudoOk) //!oGetTmp:TudoOK() //se chamar pela segunda vez, retorna true, se usar eval no btudook, retorna true
				oTFolder:nOption 	:= i //oTFolder:SetOption(i)
				lResult				:= .F.
				exit
			endif
		next
	endif

	if lResult         
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Varre todas as abas, colocando no aCols o aColsAux, caso exista³
		//³o aColsAux sera o array que tem todos os dados do aCols, inde- ³		
		//³pendente do filtro que haja nesta aba.                         ³
		//³Tem abas que sao 'filhas' de outras abas, entao o conteudo de- ³
		//³las sera demonstrado de forma filtrada, mas no aColsAux tera   ³
		//³sempre ela completa.                                           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		for i:= 1 to len(oTFolder:aDialogs)
			cColsAux	:= 'aColsAux' 	+ StrZero(i, 2)
			cCols		:= 'aCols' 		+ StrZero(i, 2)
			cHeader	:= 'aHeader'	+ StrZero(i, 2)
			cGet		:= 'oGet'		+ StrZero(i, 2)

			if len(&(cColsAux)) > 0
				&(cCols)			:= aClone(&(cColsAux))
				&(cGet):aCols	:= aClone(&(cColsAux))
			endif
		next
	endif

	if lResult

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Executa o ponto de entrada TudoOk, apos todas as validacoes 'padroes'  ³
		//³se retornar false isto invalida o tudook anterior, e a tela nao fechara³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		if ExistPe('TudoOk')
			lTudoOk	:= ExecPe('TudoOk', 'L')
			if !lTudoOk
				lResult	:= .F.
			endif
		endif
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Este trecho serve para filtrar novamente as abas que sao filhas, pois antes do tudook³
		//³este filtro eh retirado e caso de algum problema no tudook (PE) o filtro tem de ser  ³
		//³novamente posto                                                                      ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		if !lResult
			for i:= 1 to len(oTFolder:aDialogs)
				cCols				:= 'aCols' 		+ StrZero(i, 2)
				cGet				:= 'oGet'		+ StrZero(i, 2)
				&(cCols)			:= aClone(_aColsAux[i])
				&(cGet):aCols 	:= aClone(_aColsAux[i])
				GetDRefresh()
			next
		endif
	endif
	

Return lResult

//ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
//±±ºPrograma  ³ReplicaCamºAutor  ³George Allan        º Data ³  01/09/10   º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºDesc.     ³Funcao que faz a copia dos dados das tabelas do modeloaba   º±±
//±±º          ³para as tabelas de destino, isto eh usado em raras ocasioes º±±
//±±º          ³onde o cliente quer ter o historico completo das alteracoes º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºUso       ³                                                            º±±
//±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
Static Function ReplicaCampos() 
	local cHora				:= Time()
	local cData				:= DTOS(Date())
	local lResult			:= .T.
	local aOrigem			:= {}
	local aDestino			:= {}
	local aPk				:= _aSeek
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Faz validacoes gerais de estrutura, comparando as estruturas entre as ³
	//³tabelas de origem e destino, para evitar erros em tempo de aplicacao  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	if u_VldEstrut(@aOrigem, @aDestino) == .F.
		MsgInfo("Impossivel continuar, a estutura das tabelas de cópia esta inválida","Aviso")
		Return .F.
	endif             

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Monta a chave que fara o vinculo entre o cabecalho e as tabelas filhas ³
	//³Eh necessaria esta nova chave pois um mesmo registro pode ser duplicado³
	//³varias vezes, entao temos de diferenciar cada uma das copias           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	cChave	:= __cUserId + ' ' + cUserName + ' ' + cHora + ' ' + cData + ' ' + StrZero(Randomize(1, 1000), 4)

	if len(aOrigem)==0
		Return .F.
	endif
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Adiciona o recno do cabecalho³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aAdd(aOrigem[1][2],(aOrigem[1][1])->(RecNo()))

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Adiciona o recno dos itens no item 3 do array aOrigem            ³
	//³Nesta posicao havera um array com os recno dos filhos            ³
	//³Isto servira de base para a rotina saber quais registros deverao ³
	//³ser copiados                                                     ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	for i:= 1 to len(aFilhas)
		cTabFilha	:= aFilhas[i]
		(cTabFilha)->(dbSetOrder(aOrdem[i]))
		cSeek			:= &(aPK[i])
		(cTabFilha)->(dbSeek(cSeek))
		dbSelectArea(cTabFilha)
		while !(cTabFilha)->(EOF()) .AND. &(aPK[i]) == Eval(aWhile[i])
			aAdd(aOrigem[i+1][2], (cTabFilha)->(RecNo()))
			(cTabFilha)->(dbSkip())
		enddo
	next
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Varre todas as tabelas que serao duplicadas, iniciando com a de ³
	//³cabecalho                                                       ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	for i := 1 to len(aOrigem)                    
		cTabOrigem		:= aOrigem[i][1]
		cTabDestino		:= aDestino[i]
		cAliasCampo		:= iif(Left(cTabDestino,1)=='S', Right(cTabDestino,2), cTabDestino)

		aRecNo			:= aOrigem[i][2]
		for t := 1 to len(aRecNo)
			(cTabOrigem)->(dbGoTo(aRecNo[t]))
			RecLock(cTabDestino, .T.)
				for j :=1 to (cTabOrigem)->(FCount())                     
					cCampoOrigem	:= (cTabOrigem)->(Field(j))
					nPosicao_		:= At('_',cCampoOrigem)	
					cCampoDestino	:= cAliasCampo + SubStr(cCampoOrigem, nPosicao_, len(cCampoOrigem) - nPosicao_+1)
		
					(cTabDestino)->&(cCampoDestino)	:= (cTabOrigem)->&(cCampoOrigem)
				next
				(cTabDestino)->&(cAliasCampo + '_YCHAVE')	:= cChave
			(cTabDestino)->(msUnLock())
		next      
		if len(AllTrim(cChave)) >  len((cTabDestino)->&(cAliasCampo + '_YCHAVE'))
			lResult	:= .F.
			MsgInfo("Tamanho do " + cAliasCampo + "_YCHAVE insuficiente, aumente para pelo menos o tamanho " +;
			        StrZero(len(AllTrim(cChave)), 3),"Aviso")
		endif
	next

Return lResult
//ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
//±±ºPrograma  ³VldEstrut ºAutor  ³George Allan        º Data ³  01/09/10   º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºDesc.     ³Funcao que valida se a estrutura das tabelas que serao      º±±
//±±º          ³copiadas esta de acordo com as tabelas de origem            º±±
//±±º          ³                                                            º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºUso       ³                                                            º±±
//±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
User Function VldEstrut(aOrigem, aDestino)
	local lResult		:= .T. 
	local aOrigem
	local aDestino
   Default aOrigem	:= {}
   Default aDestino	:= {}
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se nao foi passado o cRepCabec, eh porque nao eh pra fazer copia³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	if Empty(cRepCabec)
		Return .T.
	endif

	aAdd(aOrigem, {cCabec, {}})

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Adiciona a tabela de cabecalho no array aOrigem, este array indicara³
	//³quais tabelas terao seus dados duplicados                           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	for i:= 1 to len(aFilhas)
		aAdd(aOrigem, {aFilhas[i], {}})
	next                                                                   
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³O array aDestino eh um array paralelo ao aOrigem, ele servira para indicar³
	//³para quais tabelas o conteudo do aOrigem sera duplicado                   ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	aAdd(aDestino, cRepCabec)
	for i:= 1 to len(aRepFilhas)
		aAdd(aDestino, aRepFilhas[i])
	next                 
	
	if len(aOrigem) <> len(aDestino)
		lResult	:= .F.
		MsgInfo("Informações passadas para o modelo aba estao inválidas, veja as variaveis cCabec, cRepCabec, aFilhas, aRepFilhas","Aviso")
		return lResult
	endif                          
	
	for i	:= 1 to len(aOrigem)                                                                   
		cTabOrigem		:= aOrigem[i][1]
		cTabDestino		:= aDestino[i]
		cAliasCampo		:= iif(Left(cTabDestino,1)=='S', Right(cTabDestino,2), cTabDestino)        

		cCampoChave	:= iif(Left(cTabDestino,1)=='S', Right(cTabDestino,2), cTabDestino) + '_YCHAVE'

/*		if Empty(Left(InfoSX3(cCampoChave),1)) .or. SX3->X3_TIPO <> 'C'
			MsgInfo("Crie o campo _YCHAVE no " + cTabDestino + " como caracter","Aviso")   
			lResult	:= .F.
		endif                                                                            
*/		
		for j :=1 to (cTabOrigem)->(FCount())
			cCampoOrigem	:= (cTabOrigem)->(Field(j))
			nPosicao_		:= At('_',cCampoOrigem)	
			cCampoDestino	:= cAliasCampo + SubStr(cCampoOrigem, nPosicao_, len(cCampoOrigem) - nPosicao_ + 1)
			if InfoSX3(cCampoOrigem) <> InfoSX3(cCampoDestino)
				cMensagem	:= 'Campo ' + cCampoOrigem + ' diferente (ou inexistente) em a estrutura do ' + cTabDestino + '<br>' 
				cMensagem	+= InfoSX3(cCampoOrigem) + '<br>'
				cMensagem	+= InfoSX3(cCampoDestino) + '<br>'				
				MsgInfo(cMensagem,"Aviso")
				lResult	:= .F.
			endif
		next
	next
Return lResult
//ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
//±±ºPrograma  ³InfoSX3   ºAutor  ³George Allan        º Data ³  01/09/10   º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºDesc.     ³Funcao auxiliar utilizada para verificar se o campo da tabe-º±±
//±±º          ³la de origem esta definido da mesma forma que o campo da    º±±
//±±º          ³tabela destino (copia)                                      º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºUso       ³                                                            º±±
//±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
Static Function InfoSX3(cCampo)
	cResult	:= ''
	SX3->(dbSetOrder(2)) // campo
	SX3->(dbSeek(cCampo))
	cResult	:= SX3->X3_TIPO + STR(SX3->X3_TAMANHO) + STR(SX3->X3_DECIMAL) + UPPER(SX3->X3_TITULO)

    oSXS:cTabela := Substr(cCampo,1,3)   // Tabela que quer pegar a estrutura
    aCpoEnchoice := oSXS:Montar()

    For nId := 1 To Len(aCpoEnchoice)
	    If AllTrim(aCpoEnchoice[nId][02]) == AllTrim(cCampo)
           cResult	:= aCpoEnchoice[nId][08] + STR(aCpoEnchoice[nId][04]) + STR(aCpoEnchoice[nId][05]) + UPPER(aCpoEnchoice[nId][01])
  		   break
	 	EndIf
    Next
Return cResult

//ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
//±±ºPrograma  ³OnChange  ºAutor  ³George Allan        º Data ³  01/09/10   º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºDesc.     ³Funcao chamada a cada mudanca de linha de cada get          º±±
//±±º          ³Tem o objetivo de filtrar registro das grids 'contra dominioº±±
//±±º          ³                                                            º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºUso       ³                                                            º±±
//±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
Static Function OnChange()
	Local aPosFil	:= {}
	Local i			
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se a tabela do aHeader tem filtro vinculado, antes eu estava ³
	//³fazendo esta verificacao baseando-me na aba escolhida, mas estava     ³
	//³dando errado na primeira (primeiras) chamada                          ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	_nPosFil	:= 0

	While (_nPosFil	:= TemDomCdom(aHeader[1][2], 1, _nPosFil + 1)) > 0
		Aadd(aPosFil, _nPosFil)
	Enddo
	
	if Len(aPosFil) > 0
		For i := 1 to Len(aPosFil)
			nPosFil	:= aPosFil[i]
			PreencheVars()
	      AtuAcols()
	
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Limpa o aAuxiliar, tirando os dados do aColsCdom atual³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			LimpaAuxiliar()
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Se for primeira vez, preenche o array completo na matriz auxiliar³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
			if PrimeiraVez()
				&(cColsAux)		:= aClone(&(cGetCdom):aCols)
			else
				//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
				//³Agrega dados do contra dominio na matriz aColsAuxXX              ³
				//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ					
				AgregaCdom()
			endif        
			cCDom	:= aFiltro[nPosFil][2]
	      AtuAcols()
			nPosFil	:= aPosFil[i]
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Preenche o contradominio, com os dados do aColsAux referentes a seu get³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	      PreencheCdom(cCdom)
	
			&(cGetCdom):Refresh(.T.)
			cTabCdom	:= aFiltro[nPosFil][2] // tabela contra dominio
			nPosFil	:= TemDomCdom(cTabCdom+"_FILIAL", 1)
			if nPosFil > 0 // o contradominio tambem eh dominio neste caso
				nPosFilha	:= aScan(aFilhas, {|aX| Upper(aX) == Upper(aFiltro[nPosFil][1])})
				&('oGet' + StrZero(nPosFilha, 2)):OnChange()
			endif
			//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
			//³Verifica se o contradominio tem contradominio, se tiver chama³
			//³o onchage do contradominio1                                  ³
			//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Next
	endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Ponto de entrada chamado no ato da mudanca de linha da aba³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	if ExistPe('onChangeLine'+StrZero(nAbaAtu,2))
		ExecPe('onChangeLine'+StrZero(nAbaAtu,2), 'L')
	endif

	if ExistPe('onChangeLine'+aFilhas[nAbaAtu])
		ExecPe('onChangeLine'+aFilhas[nAbaAtu], 'L')
	endif
	
Return 

//ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
//±±ºPrograma  ³TemDomCdomºAutor  ³George Allan        º Data ³  01/09/10   º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºDesc.     ³Funcao que indica se a tabela tem dominio ou contra dominio º±±
//±±º          ³Deve ser passado o nome do campo da tabela, e o tipo, o tipoº±±
//±±º          ³pode ser 1 para dominio e 2 para contra dominio             º±±
//±±º          ³Este numero indica a posicao do campo no array a Filtros    º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºUso       ³                                                            º±±
//±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
Static Function TemDomCdom(cCampo, nTipo, nStart)
	Default nStart := 1
	nPos_ := at('_',cCampo)
	_cTabela	:= Left(cCampo,nPos_-1)
	if len(_cTabela) == 2
		_cTabela := 'S' + _cTabela
	endif
	nPosFil			:= aScan(aFiltro, {|aX| Upper(aX[nTipo]) == Upper(_cTabela)}, nStart)
return nPosFil

//ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
//±±ºPrograma  ³AtuaCols  ºAutor  ³George Allan        º Data ³  01/09/10   º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºDesc.     ³Funcao que atualiza os aCols a partir dos oGet:aCols        º±±
//±±º          ³                                                            º±±
//±±º          ³                                                            º±±
//±±º          ³                                                            º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºUso       ³                                                            º±±
//±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
Static Function AtuAcols()
	local i
	local cCols
	local cGet
	for i:= 1 to len(aFilhas)
		cGet	:= 'oGet' 	+ StrZero(i,2)
		cCols	:= 'aCols'  + StrZero(i,2)
		&(cCols)	:= aClone(&(cGet):aCols)
	next
Return

//ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
//±±ºPrograma  ³MontaFiltrºAutor  ³George Allan        º Data ³  01/09/10   º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºDesc.     ³Funcao que monta o filtro referente aos parametros passados º±±
//±±º          ³Tem-se de ser passado o aheader do filtro, o aCols, a       º±±
//±±º          ³variavel (que pode ser o 'i' do for por exemplo, ou o nAux  º±±
//±±º          ³que eh um valor fixo (1) e o tipo de campo, se eh 1 dominio º±±
//±±º          ³e o 2 eh contra dominio                                     º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºUso       ³                                                            º±±
//±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß

Static Function MontaFiltro(cHeaderFil, cColsFil, cVarFil, nTipoCampoFil)
	local cFiltro	:= ''
	
	for j:= 1 to len(aCamposFil)
		cCampoFil	:= aFiltro[nPosFil][3][j][nTipoCampoFil]
		nPosCampo	:= GDFieldPos(cCampoFil,&(cHeaderFil))
		cFiltro		+= "+" + cColsFil +"[("+ cVarFil+")][("+StrZero(nPosCampo,3)+")]"
	next
Return cFiltro

//ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
//±±ºPrograma  ³LimpaAuxilºAutor  ³George Allan        º Data ³  01/09/10   º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºDesc.     ³Funcao que limpa da matriz auxiliar (aColsAuxXX) os         º±±
//±±º          ³registros referentes ao contra dominio atual, estes dados   º±±
//±±º          ³serao recolocados depois, mas antes disso têm de ser limpos º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºUso       ³                                                            º±±
//±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
Static Function LimpaAuxiliar()
	local aAjuda	:= {}

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se estiver excluindo ou visualizando, nao eh pra limpar³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	if EXCLUI .OR. VISUAL
		Return
	endif
	for i:= 1 to len(&(cColsAux))
		cFiltroCdom	:= MontaFiltro(cHeaderCDom, cColsCDom	, 'nAux'	, 2)
		cFiltroAux	:= MontaFiltro(cHeaderCDom, cColsAux	, 'i'		, 2)

		if &(cFiltroAux) == &(cFiltroCdom)
			&(cColsAux)[i] := nil
		endif
	next
	           
	aAjuda			:= aClone(&(cColsAux))
	&(cColsAux)		:= {}
	for i:= 1 to len(aAjuda)
		if aAjuda[i] <> nil
			aAdd(&(cColsAux), aAjuda[i])
		endif
	next
Return

//ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
//±±ºPrograma  ³PrimeiraVeºAutor  ³George Allan        º Data ³  01/09/10   º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºDesc.     ³Funcao que verifica se o aColsAuxXX ainda nao existe, para  º±±
//±±º          ³fazer a carga inicial dele.                                 º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºUso       ³                                                            º±±
//±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
Static Function PrimeiraVez()
	nPos_ := at('_',aHeader[1][2])
	_cTabela	:= Left(aHeader[1][2],nPos_-1)
	if len(_cTabela) == 2
		_cTabela := 'S' + _cTabela
	endif
	nPosFil			:= aScan(aFiltro, {|aX| Upper(aX[1]) == Upper(_cTabela)})	 
Return len(&(cColsAux)) == 0         

//ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
//±±ºPrograma  ³AgregaCdomºAutor  ³George Allan        º Data ³  01/09/10   º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºDesc.     ³Funcao que joga os dados do contradominio no aColsXX        º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºUso       ³                                                            º±±
//±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
Static Function AgregaCdom()
	if !EXCLUI .AND. !VISUAL
		for i:= 1 to len(&(cGetCdom):aCols)
			aAdd(&(cColsAux), &(cGetCdom):aCols[i])
		next
	endif
Return
//ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
//±±ºPrograma  ³PreencheCDºAutor  ³George Allan        º Data ³  01/09/10   º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºDesc.     ³Funcao que joga no aCols do contra dominio os dados do      º±±
//±±º          ³aColsAuxXX referentes a ele.                                º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºUso       ³                                                            º±±
//±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
Static Function PreencheCdom(cCdom)
	local aRetorno
	cFiltroDom	:= MontaFiltro(cHeaderDom	, cColsDom	, '&(cGetDom):nAt', 1)
	cFiltroAux	:= MontaFiltro(cHeaderCDom	, cColsAux	, 'i'					, 2)
	nPosCdom		:= aScan(aFilhas, {|aX| Upper(aX) == Upper(cCdom)})	 

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³limpa o array do contra dominio³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	&(cGetCdom):aCols	:= {}
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Adicao simples das informacoes do ContraDominio no aColsAuxXX³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	If Len(&cColsDom) > 0
		for i:= 1 to len(&(cColsAux))
			if &(cFiltroDom) == &(cFiltroAux)
	 			aAdd(&(cGetCdom):aCols, &(cColsAux)[i])
			endif
		next
	EndIf
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³se não tiver nenhum item, tem de iniciar o aCols com um item vazio³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	if len(&(cGetCdom):aCols)==0
		&(cGetCdom):AddLine(.T.)
		lAutoDel	:= .T.
		&(cGetCdom):DelLine(1)
		lAutoDel	:= .F.
	endif
	&(cColsCdom)	:= aClone(&(cGetCdom):aCols)
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se tiver excluindo ou visualizando, e nao houver itens no contra dominio, entao esconde a grid³
	//³para nao mostra-la totalmente vazia (ao dar dois cliques dava erro)                           ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	if (EXCLUI .OR. VISUAL) .AND. len(&(cColsCdom)) == 0
		&(cGetCdom):Hide()
	else
		&(cGetCdom):Show()	
	endif	
Return

//ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
//±±ºPrograma  ³PreencheVaºAutor  ³George Allan        º Data ³  01/09/10   º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºDesc.     ³Funcao que inicializa variaveis que serao utilizadas pelas  º±±
//±±º          ³outras funcoes                                              º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºUso       ³                                                            º±±
//±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
Static Function PreencheVars()
		cDom			:= aFiltro[nPosFil][1]
		nPosDom		:= aScan(aFilhas, {|aX| Upper(aX) == Upper(cDom)})
		cGetDom		:= 'oGet' 		+ StrZero(nPosDom, 2)
		cHeaderDom	:= 'aHeader' 	+ StrZero(nPosDom, 2)
		cColsDom		:= 'aCols'		+ StrZero(nPosDom, 2)
		cCdom			:= aFiltro[nPosFil][2]
		nPosCdom		:= aScan(aFilhas, {|aX| Upper(aX) == Upper(cCdom)})
		cGetCdom		:= 'oGet' 		+ StrZero(nPosCdom, 2)
		cHeaderCdom	:= 'aHeader' 	+ StrZero(nPosCdom, 2)
		cColsCdom	:= 'aCols'		+ StrZero(nPosCdom, 2)
		cColsAux		:= 'aColsAux'	+ StrZero(nPosCdom, 2)
		n:= &(cGetDom):nAt
		aCamposFil	:= aClone(aFiltro[nPosFil][3])
return


//ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
//±±ºPrograma  ³fCampoUnq ºAutor  ³George Allan        º Data ³  01/09/10   º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºDesc.     ³Funcao que verifica se existe o mesmo conteudo no aCols.    º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºUso       ³ Normalmente usada em ponto de entrada que valida a linha.  º±±
//±±º          ³ Ex. para chamar a funcao:                                  º±±
//±±º          ³                                                            º±±
//±±º          ³aCampoUnico	:= {}                                         º±±
//±±º          ³aAdd(aCampoUnico,{'ZC6_ITEM',gdFieldGet('ZC6_ITEM',n)})     º±±
//±±º          ³If !U_fCampoUnq(aCampoUnico)                                º±±
//±±º          ³	Alert('Já existe esse item na grid.')                     º±±
//±±º          ³	Return .F.                                                º±±
//±±º          ³EndIf                                                       º±±
//±±º          ³                                                            º±±
//±±º          ³Existe um exemplo desse no POTA0105.prw                     º±±
//±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
User Function fCampoUnq(aCampoUnico, _aHeader, _aCols)
	Local aHeadertemp		:= aHeader
	Local aColsTemp		:= aCols	

	Default aCampoUnico	:= {}
	Default _aHeader		:= aHeader
	Default _aCols			:= aCols	

	If Empty(aCampoUnico)
		Return .T.
	EndIf

	aHeader	:= aClone(_aHeader)
	aCols 	:= aClone(_aCols)
	
	// Forma as variaveis de comparação
	cCampos	:= ''
	cValores	:= ''
	For i:=1 to Len(aCampoUnico)
		cCampos	+= Iif(Empty(cCampos) ,"gdFieldGet('"+aCampoUnico[i][1]+"',i)",'+'+"gdFieldGet('"+aCampoUnico[i][1]+"',i)")
		cValores	+= aCampoUnico[i][2]
	Next
	
	// Precorre todo o aColse comparo se tem o mesmo conteudo em quantas linhas.
	nCont	:= 0
	for i:=1 to Len(aCols)         
		if aCols[i][Len(aHeader)+1]
			loop
		endif
		if &(cCampos) == cValores
			nCont++
		endIf
	next
	
	aHeader	:= aClone(aHeadertemp)
	aCols 	:= aClone(aColsTemp)

	If nCont > 1 // Comparo com maior que 1 porque 1 e a propria linha.
		Return .F.
	EndIf

Return .T.
//ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
//±±ºPrograma  ³LenArray  ºAutor  ³George Allan        º Data ³  04/10/10   º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºDesc.     ³Retorna o tamanho do array passado, desconsiderando as      º±±
//±±º          ³linhas jah deletadas                                        º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºUso       ³                                                            º±±
//±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
Static Function LenArray(aArray, nPosDel)
	local nResult	:= 0
	local i               
	local aArray      
	for i:=1 to len(aArray)
		if !aArray[i][nPosDel]
			nResult++
			exit
		endif
	next
return nResult
//ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
//±±ºPrograma  ³OnChangeAbºAutor  ³George Allan        º Data ³  05/10/10   º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºDesc.     ³Funcao que sera executada a cada mudanca de aba, esta funcaoº±±
//±±º          ³atualiza a variavel nAbaAtu, que indica qual eh a aba atual º±±
//±±º          ³Ou seja, o nAbaAtu sera sempre igual ao oTFolder:nOption,   º±±
//±±º          ³Mas no caso de querermos utilizar o ponto de entrada        º±±
//±±º          ³OnChangeAba sera util esta variavel pois ela indicara a aba º±±
//±±º          ³'anterior', ou seja, a aba que perdeu o foco                º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºUso       ³                                                            º±±
//±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
Static Function onChangeAba()
	local lOnChangeAba	:= .T.
	cGet	:= 'oGet' + StrZero(nAbaAtu, 2)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³So chama o tudo ok se estiver tentando mudar de aba³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	if oTFolder:nOption <> nAbaAtu
		lOnChangeAba			:=&cGet:TudoOk()
	endif
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se mudou de aba, chama o PE de mudanca de linha, este PE nao³
	//³estava sendo chamado quando se mudava a aba                 ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	if lOnChangeAba
		if ExistPe('onChangeLine'+StrZero(nAbaAtu,2))
			ExecPe('onChangeLine'+StrZero(nAbaAtu,2), 'L')
		endif
	
		if ExistPe('onChangeLine'+aFilhas[nAbaAtu])
			ExecPe('onChangeLine'+aFilhas[nAbaAtu], 'L')
		endif		
	endif
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Chama o ponto de entrada de mudanca de aba, so chama se o 'tudook'³
	//³do get retornar true                                              ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	if lOnChangeAba .AND. ExistPe('onChangeAba') .AND. oTFolder:nOption <> nAbaAtu
		lOnChangeAba	:= ExecPe('onChangeAba', 'L')
	endif

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se permitir mudar de aba, atualiza o nAbaAtu com a nova aba³
	//³Se nao permitir, retorna para a aba anterior               ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	if !lOnChangeAba
		oTFolder:nOption	:= nAbaAtu
	else
		nAbaAtu	:= oTFolder:nOption
	endif
Return .T.

//ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
//±±ºPrograma  ³VldArray  ºAutor  ³George Allan        º Data ³  05/10/10   º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºDesc.     ³Faz validacoes basicas nos arrays passados para o modeloaba º±±
//±±º          ³                                                            º±±
//±±º          ³                                                            º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºUso       ³                                                            º±±
//±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
Static Function VldArray()
	local i, j, y, z, cIndice, cCampoAux
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se ha alguma inconsistencia entre o aOrdem e o _aChave³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	for i:= 1 to len(aFilhas)
		cIndice	:= ''    
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Se for passado o nickname do indice, modifico para o numero dele³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

		if ValType(aOrdem[i]) == 'C'
			if ! (aFilhas[i])->(dbOrderNickName(aOrdem[i]))
				MsgInfo("Indice " + aOrdem[i] + " não existe","Aviso")
				Return
			endif
			aOrdem[i] := (aFilhas[i])->(IndexOrd())
		endif
		if ValType(aOrdItem[i]) == 'C'
			if !(aFilhas[i])->(dbOrderNickName(aOrdItem[i]))
				MsgInfo("Indice " + aOrdItem[i] + " não existe","Aviso")
				Return
			endif
			aOrdItem[i]	:= (aFilhas[i])->(IndexOrd())
		endif		
		if _aChave[i] <> nil
			for j:= 1 to len(_aChave[i])
				cIndice	+= iif(j<>1,'+','') + _aChave[i][j][1]
			next
			nOrdemAux	:= &(aFilhas[i])->(IndexOrd())
			&(aFilhas[i])->(dbSetOrder(aOrdItem[i]))

			cIndiceTMP	:= &(aFilhas[i])->(IndexKey())
			cIndiceTMP:=StrTran(cIndiceTMP,'DTOS(','')
			cIndiceTMP:=StrTran(cIndiceTMP,')','')
			if ! (cIndice $ cIndiceTMP)
//			if ! (cIndice $ &(aFilhas[i])->(IndexKey()))
				MsgInfo("Ajuste o _aChave do " + aFilhas[i] + ", não está batendo com o indice escolhido no aOrdItem " + chr(13) + chr(10);
						+ " indice informado no _aChave: " + cIndice + chr(13) + chr(10);
						+ " indice escolhido no aOrdem: " + AllTrim(Str(aOrdItem[i])) + chr(13) + chr(10);
						+ " com conteudo: " + cIndiceTMP,"Aviso")
				Return .F.
			endif                                 
		endif
		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Os campos sequenciais sao obrigatorios, tem de haver ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		if !aReadOnly[i] .AND. (aIniPos[i] == nil .or. Empty(aIniPos[i]))
			MsgInfo("É obrigatório a aba ter um campo 'sequencial', preencha no aIniPos com a sintaxe similar a "+  chr(13) + chr(10);
					+ " aAdd(aIniPos , ZCE_SEQ )","Aviso")
			Return
		endif    

		//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
		//³Valida se os campos de filtro entre abas estao marcados como ³
		//³usados e sao reais                                           ³
		//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
/*		for j:= 1 to len(aFiltro)
			for y:= 1 to len(aFiltro[j][3])
				for z:= 1 to 2
					cCampoAux	:= aFiltro[j][3][y][z]
					InfoSX3(cCampoAux)
					if ! X3USO(SX3->X3_USADO) .OR. SX3->X3_CONTEXT $ ('rR') 
						MsgInfo("Campo " + cCampoAux + " tem de ser marcado como usado e ser contexto real","Aviso")
						Return .F.
					endif
				next
			next
		next
*/		
		&(aFilhas[i])->(dbSetOrder(nOrdemAux))
	next
Return .T.
                                                 
//ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
//±±ºPrograma  ³CalcTotal ºAutor  ³George Allan        º Data ³  21/10/10   º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºDesc.     ³Funcao auxiliar que atualiza no cabecalho um campo totali-  º±±
//±±º          ³zador que depende dos itens.                                º±±
//±±º          ³Para utiliza-la coloque como um gatilho do campo que esta   º±±
//±±º          ³sendo alterado para o campo que esta sendo alterado         º±±
//±±º          ³Exemplo, o campo total do SC6 (C6_TOTAL) deve ir para o     º±±
//±±º          ³C5_TOTALC6. Entao, no campo C5_QTD devemos criar um gatilho º±±
//±±º          ³apontando para ele mesmo com a funcao u_calctotal('C5_TOTAL'º±±
//±±º          ³,'C6_TOTAL), teriamos de fazer isso para o C6_VLRUNIT tambemº±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºUso       ³                                                            º±±
//±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
User Function CalcTotal(cCampoDestino, cCampoOrigem, _aAuxHeader, _aAuxCols, cCondicao)
	private y                       
	private nTotal			:= 0
	Default _aAuxHeader	:= aHeader
	Default _aAuxCols		:= aCols
	Default cCondicao		:= '.T.'

//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
//³Exemplo do parametro cCondicao:                                        ³
//³AllTrim(gdFieldGet('ZZT_TIPO',y,,oGet01:aHeader, oGet01:aCols)) == 'FI'³
//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	For y := 1 to Len(_aAuxCols)           
		 // Se não estiver deletado soma.
		if !_aAuxCols[y][Len(_aAuxHeader)+1] .AND. &(cCondicao)
			nTotal += gdFieldGet(cCampoOrigem,y,.F., _aAuxHeader, _aAuxCols)
		EndIf
	Next  

	M->&(cCampoDestino)	:= nTotal
	oEnchoice:Refresh()
//	GetDRefresh()
Return M->&(ReadVar())

Static Function Ref
	
Return .t.
//ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
//±±ºPrograma  ³DelCDom   ºAutor  ³George Allan        º Data ³  25/10/10   º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºDesc.     ³Funcao auxiliar chamada a cada tentativa de delecao de uma  º±±
//±±º          ³linha do array                                              º±±
//±±º          ³Esta funcao verifica se o item do get que esta sendo deleta-º±±
//±±º          ³do tem filhos, e se algum dos filhos estiver 'desdeletado'  º±±
//±±º          ³a funcao nao deixa deletar a linha.                         º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºUso       ³                                                            º±±
//±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
User Function DelCDom()
	local cGetAtu	:= 'oGet' + StrZero(nAbaAtu, 2)
	local nCDom		:= 0
	local cGetCDom
	local i          
	local lPodeApagar	:= .T. 

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se for uma delecao (eh que pode haver a desdelecao tb) ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	local lEstaDeletando := !(&cGetAtu:aCols[&cGetAtu:nAt][len(&cGetAtu:aHeader)+1])

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Verifica se tem contra dominio³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	nCDom		:= TemDomCdom(&(cGetAtu):aHeader[1][2], 1)
	if nCDom == 0
		Return .T.
	endif
	cCDom		:= aFiltro[nCDom][2]
	nPosCDom	:= aScan(aFilhas, {|aX| Upper(aX) == Upper(cCDom)})
	cGetCDom	:= 'oGet' + StrZero(nPosCDom, 2)

	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Varre a tabela filha verificando se tem algum item nao deletado (vivo)³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	for i:= 1 to len(&cGetCDom:aCols)
		if !&cGetCDom:aCols[i][len(&cGetCDom:aHeader)+1]
			lPodeApagar	:= .F.
		endif
	next                                                                      
	
	//ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
	//³Se houver pelo menos um item nao deletado nos filhos, entao nao permite        ³
	//³deletar o pai                                                                  ³
	//ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	if !lPodeApagar
		MsgAlert("Não é possível apagar, item tem filhos","Aviso")
	endif
Return lPodeApagar

//ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
//±±ºPrograma  ³InicGrid  ºAutor  ³George Allan        º Data ³  26/10/10   º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºDesc.     ³Funcao auxiliar utilizada em inicializador padrao de grid   º±±
//±±º          ³Normalmente ela eh utilizada quando o inicializador do campoº±±
//±±º          ³depende da linha superior da grid.                          º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºUso       ³                                                            º±±
//±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
User Function InicGrid(cGet, cCampo)
	local nLinhaAtual
	local cResult		:= ''
	if oDlg:lCentered // se o dialogo estiver ativo (tenho de procurar a propriedade que indica isso, por enquanto uso o centered
		nLinhaAtual	:= len(&cGet:aCols)
  		if nLinhaAtual > 1
			cResult	:= GdFieldGet(cCampo)
		endif
	endif                   
Return cResult

//ÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜÜ
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//±±ÉÍÍÍÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍËÍÍÍÍÍÍÑÍÍÍÍÍÍÍÍÍÍÍÍÍ»±±
//±±ºPrograma  ³ COPIAABA º Autor ³ George Allan       º Data ³  10/08/12   º±±
//±±ÌÍÍÍÍÍÍÍÍÍÍØÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÊÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍ¹±±
//±±ºDescricao ³ Função fazer a copia                                       º±±
//±±ÈÍÍÍÍÍÍÍÍÍÍÏÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼±±
//±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±±
//ßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßßß
User Function COPIAABA(cFunction, lQuestion, aFieldsCopia)
	Static lCopia			:= .F.
	default lQuestion		:= .T.
	default aFieldsCopia	:= {}
	
	if lQuestion .AND. !MsgYesNo('Deseja fazer uma copia?')
		Return .F.
	endIf
	
	lCopia	:= .T.
	U_modeloaba(4, cFunction, aFieldsCopia)
	lCopia	:= .F.
Return .T.    

User Function ModeAbaExe(cComando)

&(cComando)

Return
